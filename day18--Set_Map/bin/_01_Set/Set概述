Set概述：
	Set是Collection的子接口，模拟了数学上的集的概念
*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*
Set集合储存的特点：
	1）：不允许元素重复
	2）：不会记录元素的先后添加顺序
*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*
	Set只是包含了从Collection继承的方法，不过Set无法记住添加的顺序，不允许包含重复的元素，当试图添加两个相同元素进
Set集合，添加操作失败，add()方法返回false
	Set判断两个对象是否相等用equals而不是==
*******************************************************
Set接口的实现类：
	共同的特点：
		1）：都不允许元素重复
		2）：都不是线程安全的类
		解决方案：Set s = Collection.synchronizedSet(Set对象)
	##HashSet：不保证元素的先后添加顺序，绝大多是采用HashSet
		底层采用的是哈希表算法，查询效率极高
		&&判断两个对象是否是相等的规则：1）equals比较为true；2）hashCode值相同
			要求：存在哈希表中的对象元素都得覆盖equals和hashCode方法
	##LinkedHashSet：
		HashSet的子类，底层也采用的是哈希表算法，但是也使用了链表算法来维持元素的先后添加顺序
		&&判断两个对象是否相等的规则和HashSet相同
		因为需要多使用一个链表来记录元素的顺序，所以性能稍低，一般少用
	##TreeSet：不保证元素的先后添加顺序，但是会对元素做排序操作
		底层采用的是红黑树算法（树结构，比较适合做范围查询）
		TreeSet要么采用自然排序，要么采用定制排序
		&&判断两个元素对象重复的规则
				compareTo/compare方法是否返回0，如果返回0，则视为是同一个对象
-----------------------------------------------------------
HashSet做等值查询效率高，TreeSet做范围查询效率高
	而我们更多的情况都是做等值查询，在数据库的索引中，做范围查询较多，所以树结构主要用于做索引，用来提高查询效率



