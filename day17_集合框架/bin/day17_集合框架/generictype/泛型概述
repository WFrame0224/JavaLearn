为什么需要使用泛型：
	1）存储任意类型的数据在集合中，但是取出来的元素都是Object类型的，此时就得强转，见Why.java
	2）约束存储到集合中的元素必须是相同的数据类型(相同的数据类型才能做比较，比如TreeSet类 )
	3）设计一个点（point）类，来封装坐标位置，支持String类型，Integer类型，Double类型
*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*
泛型（GenericType）从java5开始支持的新的语法：//常用公认泛型符：T：type   E：Elements	K：Key		V：Value
	什么是泛型：
			1）：广泛通用的类型
			2）：代码模板中类型不确定，谁调用该代码，谁指明类型是什么
***********************************************
泛型类：直接在类/接口上定义的泛型
	使用泛型：
	保证前后类型相同
	List<String> list = new ArrayList<String>();//该list集合中只能存储String类型的元素
	因为前后类型相同，所以从Java7开始，退出泛型的菱形语法<>
		-->:List<String> list = new ArrayList<>()
	注:泛型不存在继承关系（错误如下）：List<Object> list = new ArrayList<String>()
	从此以后，使用集合都得使用泛型来约束该集合中元素的类型.
	--通过反编译发现，泛型其实也是语法糖，底层依然没有泛型，依然采用强制转换
************************************************
泛型方法：在方法上声明泛型
	情况1）：泛型类中的泛型只能适用于非静态方法，如果需要给静态方法设置泛型，此时需要使用泛型方法
		                                      *――*――*――*――*――*――*――*――*――*――*――*――*――*――*――								
	情况2）：泛型类中的泛型应该适应于整个类中的多个方法，有时候只对某一个方法设置泛型即可.
	---------------------------------
	一般的，把自定义的泛型作为该方法的返回类型才有意义，而且此时的泛型必须是由参数设置进来的，
如果没有参数来设置泛型的具体类型，此时的方法一般返回设计为Object即可
	public static <T> T doWork(T val){
		return val;
	}
*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*――*
泛型的通配符和上限和下限：
	**泛型的通配符：不知道使用什么类型接收的时候，可以使用“？”（？表示未知，通配符）
	此时只能接收数据，不能往集合中存储数据
	**泛型的上限和下限：用来限定元素的类型必须是X类的子类或相同，父类或相同
*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_*_**_
泛型的插入和转换：
	泛型的擦除：
			1）：泛型编译之后就消失了（泛型自动擦除）
			2）：把带有泛型的集合赋给不带泛型的集合，此时泛型被删除(手动删除)
	堆污染：
		当一个方法既使用泛型的时候也使用可变参数，此时容易导致堆污染
		如在Arrays类中的aslist方法。
		