多线程通信的时候，很容易造成死锁，死锁无法解决，只能避免：
	当A线程等待由B线程持有的锁，而B线程正在等待由A线程持有的锁时，发生死锁现象，
JVM不检测也不试图避免这种情况，所以程序员必须保证不导致死锁
	**避免死锁的法则**：当多个线程都要访问共享 的资源A，B，C时，保证每一个线程都按照相同的顺序去访问他们，比如都先访问A，接着B，最后C
	------------------
	哲学家吃面的故事
	------------------
	Thread类中过时的方法：
		suspend():使用正在运行的线程放弃CPU，暂停运行
		resume():使暂停运行的线程恢复运行
		但是，上诉两种方法容易导致死锁，所以已经被废弃了
		死锁情况：
				A线程获得对象锁，正在执行的一个同步方法，如果B线程调用A线程的suspend方法，此时A线程暂停运行，A线程放弃CPU，但是不会放弃占用的锁