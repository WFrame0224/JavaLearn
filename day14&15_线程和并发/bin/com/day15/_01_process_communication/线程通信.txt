线程通信：不同线程执行不同的任务，如果这些任务有某种关系，线程之间必须能够通信，协调完成工作
	
	经典的生产者和消费者案例（Producer/Consumer）
	分析案例：
		1）：生产者和消费者应该操作共享的资源(实现方式来做)
		2）：使用一个或者多个线程来表示生产者（Producer）
		3）：使用一个或多个线程来表示消费者（Consumer）
		
分析生产者和消费者案例存在的问题：
	建议在生产姓名和性别之间以及在打印之前使用Thread.sleep(10)，使得问题出现的效果更加明显
	此时可能出现下面的情况
					凤姐姐-男
					凤姐姐-女
					春哥哥-女
					凤姐姐-男
	**问题一：出现性别紊乱的情况
		解决方案：只要保证在生产姓名和性别的过程中保持同步，中间不能被消费者线程进来取走数据
			可以使用同步代码块/同步方法/lock机制来保持同步性.
			----------------------------------------------------------
			-同步锁池：同步锁池  必须  选择多个线程共同的资源对象
			-	当前生产者在生产数据的时候（现拥有同步锁），其他线程就在锁池中等待获取
			-	当线程执行完同步代码块的时候，就会释放同步锁，其他线程开始抢占锁的使用权
			----------------------------------------------------------
			
	**问题二：应该交替出现生产一个数据，消费一个数据
				即应该交替出现：春哥哥-男-->风姐姐-->春哥哥-男-->风姐姐-->...
		解决方案：得使用   等待唤醒机制
			-----------------------------------------
			java.lang.Object类提供了两类用于操作线程通信的方法
			wait():执行该方法的线程对象释放同步锁，JVM把该线程存放到等待池中，等待其他线程唤醒该线程
			notify():执行该方法的线程，唤醒等待池中 等待的 任意一个线程，把线程转到锁池中等待
			notifyAll():执行该方法的线程，唤醒等待池中等待的所有线程，把线程转到锁池中等待
				注意：该方法  只能被同步监听锁对象来调用，否则报错IllegagMonitorStateException...
			****************************************************************************
			假设A线程和B线程共同操作一个X对象（同步锁）A，B线程可以通过X对象的wait和notify方法来进行通信，流程如下
			1：当A线程执行X对象的同步方法时，A线程持有X对象的锁，B线程没有执行机会，B线程在X的对象的锁池中等待
			2：A线程在同步方法中执行X.wait()方法时，A线程释放X对象的锁，A线程进入X对象的等待池中
			3：在X对象锁池中等待锁的B线程获取X对象的锁，执行X的另一个同步方法
			4：B线程在同步方法中执行X.notify()方法时，JVM把A线程从X对象的等待池中移动到X对象的锁池中，等待获取锁
			5：B线程执行完同步方法，释放锁，A线程获得锁，继续执行同步方法