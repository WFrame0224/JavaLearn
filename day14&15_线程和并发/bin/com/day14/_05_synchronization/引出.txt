多线程并发访问同一个资源的安全性问题：（接吃苹果比赛的例子）
	解决方案：保证打印苹果编号和苹果总数减1操作 同步完成
			 A线程进入操作的时候，B和C线程只能在外等着，A操作结束，B和C才有机会进入代码去执行
--------------------------------------------------------------------------------------------
方式1：同步代码块
	synchronized(同步锁)
	{
		需要被同步操作的代码块
	}
	注：***
		同步锁：为了保证每一个线程都能够正常执行原子操作，java引入了线程同步机制，对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁
		又叫做：同步监听对象/同步锁/同步简体器/互斥锁
		java程序运行使用的任何对象作为同步监听对象，但是一般的，我们把 当前并发访问的共同资源作为同步监听对象
		注意：在任何时候最多允许一个线程拥有同步锁，谁拿到锁就能进入代码块，其他线程就只能在代码块外等待
********************************************************************************************
方式2：同步方法
	使用synchronized修饰的方法，就叫做同步方法，但是不要使用synchronized修饰run方法，修饰之后某一个线程就执行完了所有的功能
				解决方案：把需要同步操作的代码定义在一个新的方法中，并且该方法使用synchronized修饰，再在run方法中调用该新的方法即可。
	保证了A线程执行该方法的时候，其他线程只能在方法外等着
	synchronized public void doWork(){
		//TODO
	}
	此时的同步锁是：
				对于非static方法，同步锁就是this
				对于static方法,我们使用当前方法所在类的字节码对象 如Person1.class
********************************************************************************************
以上两种采用synchronized修饰的方式
好处：保证了多线程并发访问时的同步操作，避免线程的安全性问题
缺点:使用以上两者方式，性能会低点
建议：尽量减少synchronized的作用域
********************************************************************************************
方式3：锁机制Lock
	Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块和同步方法具有的功能Lock都有，除此
	之外更加强大，更能体现面向对象
   class X {
   private final ReentrantLock lock = new ReentrantLock();//先创建一个锁对象
   // ...

   public void m() { 
     lock.lock();  //进入方法，立马加锁
     try {
       // ... method body
     } finally {
       lock.unlock()//执行完方法，开锁走人
     }
   }
 }
	
