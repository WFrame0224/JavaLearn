线程的生命周期：六种状态
	*1.新建状态（New）创建一个线程对象，仅仅在堆中分配内存空间，在调用start方法前
		新建状态下，线程压根就没有启动，仅仅只是存在一个线程对象而已
		Thread t = new Thread();//此时t就属于新建状态
		
	当新建状态下的线程对象调用了start方法，此时，从新建状态分别进入可运行状态，
		但是线程对象的start方法只能调用一次,否则报错：IllegalThreadStateException
	*2.可运行状态(runnable):分成了两种状态，ready和running。分别表示就绪状态和可运行状态
		1）：就绪状态：线程调用start方法之后，等待JVM的调度（此时该线程并没有运行）
		2）：运行状态：线程对象或得JVM调度，如果存在多个CPU，那么允许多个线程并行运行
	*3.阻塞状态(blocked):正在运行的线程因为某些原因而放弃CPU，暂时停止运行，就会进入阻塞状态
		此时JVM不会给线程重新分配CPU，直到线程重新进入就绪状态，才有机会到运行状态
			阻塞状态-->就绪状态-->运行状态
	        阻塞状态有两种情况：
		1）：当A线程处于运行过程时，试图阻止获取同步锁时，却被B线程获取，
			此时JVM把A线程存到对象的锁池中，A线程进入到阻塞状态
		2）：当线程处于运行过程中时，发出了IO请求，此时进入阻塞状态
	*4.等待状态（waiting）--等待状态只能被其他线程唤醒--无参
		1）：当线程处于运行过程中，调用了wait()方法，此时JVM把当前对象存在对象等待池中
		2）：当前线程执行了sleep()方法
	*5.计时等待状态（timed waiting）--时间到达，主动进入状态--有参
		1）：当线程处于运行过程时，调用了wait(long time)方法，此时JVM把当前线程存在对象等待池中
		2）：当前线程执行了sleep(long time)方法
	*6.终止状态（terminated）:表示线程终止
		1）：正常执行完run方法而退出
		2）：遇到异常而退出（出现异常之后，程序就会中断）
	----------------------------------------------------
	线程一旦终止，就不能重新启动	