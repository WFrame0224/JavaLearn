序列化和反序列化：
	序列化：指把 堆内存中的对象数据，通过某种方式，存储到磁盘文件中或者传递给其他网络的节点（在网络上传输）
		我们把这个过程称为序列化
	反序列化：把磁盘文件中的对象数据或者把网络节点的对象数据，恢复成Java对象的过程
	
	为什么需要做序列化：
		1）：在分布式系统中，需要共享数据的JavaBean对象，都得做序列化，此时需要把对象在网络上传输。
		以后存储在HTTPSession中的对象，都应该实现序列化接口（只有实现序列化接口的类才能做序列化操作）
		2）：服务器钝化：如果服务器发现某些对象好久都没有活动了，此时服务器就会把这些内存中的对象持久化在本地磁盘文件中（java对象-->二进制文件）
			如果发现某些对象需要活动的时候，就先在内存中寻找，找到就使用，找不到就再去磁盘文件中，反序列化我们得将序列化对象恢复成java对象

需要做序列化的对象的类，必须实现序列化接口：java.lang.Serializable接口(标致接口，没有抽象方法)
	底层会判断，如果当前对象是serializable的实例，才允许做序列化。 boolean ret = Java对象 instanceof Serializable
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
使用对象流来完成序列化和反序列化操作：
	ObjectOutputStream:通过writeObject方法做序列化操作
	ObjectInputStream:通过readObject方法做反序列化操作
    ==>Exception in thread "main" java.io.NotSerializableException: day21._01_object_stream.User
    此时报错：User类没有实现序列化接口，java.io.Serializable
    做反序列化操作必须存在对象的字节码对象

*************************************************************************************************************
序列化的细节和序列化的版本：
	1>:如果某些数据不需要序列化，比如密码：此时怎么办？
		理论上讲：静态的字段和瞬态的字段是不能做序列化操作的
		 比较好的是瞬态的字段采用 transient修饰符修饰
	2>:序列化的版本问题
		反序列化java对象时必须提供该对象的class文件，现在问题是随着项目的升级，系统的class文件也会升级（增加一个字段/删除一个字段）
		，如何保证两个class文件的兼容性？java通过serialVersionUID（序列化版本号）来判断字节码是否发生改变
	如果不显示定义serialVersionUID类变量，该变量的值由JVM根据类相关信息计算，而修改后的类的计算方式和之前往往不同
	从而造对象反序列化，因为版本不兼容而造成的失败的问题。
		解决方案：在类中提供一个固定的serialVersionUID
		//需要序列化的对象
		//需要序列化的对象
	public class User implements java.io.Serializable{
		private static final long serialVersionUID = -7681006539513141787L;
		・・・